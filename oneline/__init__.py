(_com := lambda *a, **kw: ..., importer := __import__("importlib").import_module, ast := importer("ast"), asyncio := importer("asyncio"), discord := importer("discord"), commands := importer(".commands", "redbot.core"), typing := importer("typing"), json := importer("json"), Config := importer(".config", "redbot.core").Config, types := importer("types"), coro := lambda f, doc=None, **a: (y := types.coroutine(f), setattr(y, "__code__", y.__code__.replace(co_flags=y.__code__.co_flags | 128)), setattr(y, "__doc__", doc), setattr(y, "__annotations__", a))[0], a_try := coro(lambda t, *a, f=lambda a: a, e=Exception, **kw: ([r for globals()["r"] in [{}]][0]).pop("r", (yield from (type("", (), {"__call__": (lambda self, func: (env := {"self": self, "func": func, "discord": discord}, exec(compile("async def inner(*args, **kwargs):\n\tasync with self:\n\t\treturn await discord.utils.maybe_coroutine(func, *args, **kwargs)", filename=__name__, mode="exec", flags=ast.PyCF_ALLOW_TOP_LEVEL_AWAIT, optimize=0), env), env["inner"])[-1]), "__aenter__": coro(lambda self: self), "__aexit__": coro(lambda self, *a: isinstance(a[1], e) and [r.update(r=(yield from discord.utils.maybe_coroutine(f, a)))]),})()(t)(*a, **kw))))), _com("This function is an unfortunate necessary evil. Python 3.10 would be a lot better for this, but alas, Red does not yet support it"), OneLine := type("OneLine", (commands.Cog,), {"__init__": lambda self, bot: (None, setattr(self, "bot", bot), setattr(self, "config", Config.get_conf(self, 544974305445019651, True)), self.config.register_guild(embeds={}))[0], "embed_com": (embed_com := commands.group("embed")(coro(lambda self, ctx: ..., "The base command for embeds", self=typing.Any, ctx=commands.Context))), "cog_check": coro(lambda self, ctx: ctx.guild is None or ctx.channel.permissions_for(ctx.me).embed_links), "embed_add": commands.mod()(commands.guild_only()(embed_com.command(name="add")(coro(lambda self, ctx, name, *, payload: ((yield from ctx.send("Your syntax was not correct")) if not (res := (yield from a_try(lambda payload: json.loads(payload), payload, f=lambda a: False, e=json.JSONDecodeError))) else (embeds := (yield from self.config.guild(ctx.guild).embeds().__await__()), (yield from ctx.send("An embed with that name already exists")) if embeds.get(name) else (embed := discord.Embed.from_dict(res), embeds.__setitem__(name, embed.to_dict()), _com("Here we get rid of extra clutter by using `from_dict(res).to_dict()`"), (yield from self.config.guild(ctx.guild).embeds.set(embeds).__await__()), (yield from ctx.send("Done, added that as an embed", embed=embed))))), "Add an embed to the config.\n\n**Arguments**\n- `name` The name of the embed.\n- `payload` The json payload for the embed", self=typing.Any, ctx=commands.Context, name=str, payload=str)))), "embed_list": commands.guild_only()(embed_com.command(name="list")(coro(lambda self, ctx: (data := (yield from self.config.guild(ctx.guild).embeds().__await__()), msg := "\n".join(f"`{k}`" for k in data.keys()), (yield from ctx.send(f"**{ctx.guild.name}'s Embeds**\n\n{msg}"))), "List the embeds currently stored in your guild", self=typing.Any, ctx=commands.Context))), "embed_show": commands.guild_only()(embed_com.command(name="show")(coro(lambda self, ctx, name: (embeds := (yield from self.config.guild(ctx.guild).embeds().__await__()), emb := embeds.get(name), (yield from ctx.send("I could not find an embed with that name")) if not emb else (yield from ctx.send(embed=discord.Embed.from_dict(emb)))), "Show a stored embed\n\n**Arguments**\n- `name` The name of the embed to show", self=typing.Any, ctx=commands.Context, name=str))), "embed_delete": commands.mod()(commands.guild_only()(embed_com.command(name="delete")(coro(lambda self, ctx, name: (embeds := (yield from self.config.guild(ctx.guild).embeds().__await__()), (yield from ctx.send("I could not find an embed with that name")) if not embeds.pop(name, None) else (yield from self.config.guild(ctx.guild).embeds.set(embeds).__await__()), (yield from ctx.send("Done. Removed that embed."))), "Delete an embed\n\n**Arguments**\n- `name` The name of the embed to delete", self=typing.Any, ctx=commands.Context, name=str))))}), setup := coro(lambda bot: (yield from bot.add_cog(OneLine(bot)))), teardown := coro(lambda bot: (yield from bot.remove_cog("OneLine"))), _com("A quirk about one line cogs is that they require `teardown` to be specified, otherwise the cog won't actually unload"))